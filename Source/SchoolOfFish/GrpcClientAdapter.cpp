
//
// This file has been generated by the Cornerstone file generator.
//
// PLEASE, DO NOT EDIT IT MANUALLY
//

#include "GrpcClientAdapter.h"
#include "RpcClientWorker.h"
#include "CastUtils.h"
#include "GrpcIncludesBegin.h"
#include <grpc/support/log.h>
#include <grpc++/channel.h>
#include "Proto_Generated/ActorOperation.pb.h"
#include "Proto_Generated/ActorOperation.grpc.pb.h"
#include "ChannelProvider.h"
#include "GrpcIncludesEnd.h"
namespace casts
{
    template <>
    FORCEINLINE FActorInstanceInfo Proto_Cast(const rpc::ActorInstanceInfo& Item)
    {
        FActorInstanceInfo OutItem;

        OutItem.instanceIndex = Item.instanceindex();
        OutItem.position      = FVector(Item.position().x(), Item.position().y(), Item.position().z());
        OutItem.velocity      = FVector(Item.velocity().x(), Item.velocity().y(), Item.velocity().z());
        OutItem.acceleration  = FVector(Item.acceleration().x(), Item.acceleration().y(), Item.acceleration().z());

        OutItem.steerCohesion   = FVector(Item.steercohesion().x(),   Item.steercohesion().y(),   Item.steercohesion().z());
        OutItem.steerSeparation = FVector(Item.steerseparation().x(), Item.steerseparation().y(), Item.steerseparation().z());
        OutItem.steerAlignmen   = FVector(Item.steeralignmen().x(),   Item.steeralignmen().y(),   Item.steeralignmen().z());

        OutItem.steerCohesionCnt   = Item.steercohesioncnt();
        OutItem.steerSeparationCnt = Item.steerseparationcnt();
        OutItem.steerAlignmentCnt  = Item.steeralignmentcnt();

        return OutItem;
    }

    template <>
    FORCEINLINE rpc::ActorInstanceInfo Proto_Cast(const FActorInstanceInfo& Item)
    {
        rpc::ActorInstanceInfo OutItem;

        OutItem.set_instanceindex(Item.instanceIndex);
        *OutItem.mutable_position()     = rpc::Vector3D(Item.position.X, Item.position.Y, Item.position.Z);
        *OutItem.mutable_velocity()     = rpc::Vector3D(Item.velocity.X, Item.velocity.Y, Item.velocity.Z);
        *OutItem.mutable_acceleration() = rpc::Vector3D(Item.acceleration.X, Item.acceleration.Y, Item.acceleration.Z);

        *OutItem.mutable_steercohesion()   = rpc::Vector3D(Item.steerCohesion.X,   Item.steerCohesion.Y,   Item.steerCohesion.Z);
        *OutItem.mutable_steerseparation() = rpc::Vector3D(Item.steerSeparation.X, Item.steerSeparation.Y, Item.steerSeparation.Z);
        *OutItem.mutable_steeralignmen()   = rpc::Vector3D(Item.steerAlignmen.X,   Item.steerAlignmen.Y,   Item.steerAlignmen.Z);

        OutItem.set_steercohesioncnt(Item.steerCohesionCnt);
        OutItem.set_steerseparationcnt(Item.steerSeparationCnt);
        OutItem.set_steeralignmentcnt(Item.steerAlignmentCnt);

        return OutItem;
    }

    template <>
    FORCEINLINE FActorInstanceTransform Proto_Cast(const rpc::ActorInstanceTransform& Item)
    {
        FActorInstanceTransform OutItem;
        rpc::Transform transf  = Item.transform();
        rpc::Vector3D rotation = transf.rotation();
        rpc::Vector3D location = transf.position();
        rpc::Vector3D scale    = transf.scale();

        OutItem.id = Item.index();
        OutItem.transf = FTransform(FRotator(rotation.x(),
                                             rotation.y(),
                                             rotation.z()),
                                    FVector(location.x(),
                                            location.y(),
                                            location.z()),
                                    FVector(scale.x(),
                                            scale.y(),
                                            scale.z()));

        return OutItem;
    }

    template <>
    FORCEINLINE rpc::ActorInstanceTransform Proto_Cast(const FActorInstanceTransform& Item)
    {
        rpc::ActorInstanceTransform OutItem;

        FRotator rotation = Item.transf.Rotator();
        FVector location  = Item.transf.GetLocation();
        FVector scale     = Item.transf.GetScale3D();
        *OutItem.mutable_transform() = rpc::Transform(rpc::Vector3D(rotation.Pitch, rotation.Yaw, rotation.Roll),
                                                      rpc::Vector3D(location.X, location.Y, location.Z),
                                                      rpc::Vector3D(scale.X, scale.Y, scale.Z));

        return OutItem;
    }

    template <>
    FORCEINLINE FActorEnvironmentInfo Proto_Cast(const rpc::ActorEnvironmentInfo& Item)
    {
        FActorEnvironmentInfo OutItem;
        OutItem.instanceCount = Item.instancecount();

        OutItem.radiusCohesion   = Item.radiuscohesion();
        OutItem.radiusSeparation = Item.radiusseparation();
        OutItem.radiusAlignment  = Item.radiusalignment();

        OutItem.mapRangeX = Item.maprangex();
        OutItem.mapRangeY = Item.maprangey();
        OutItem.mapRangeZ = Item.maprangez();

        OutItem.kCohesion   = Item.kcohesion();
        OutItem.kSeparation = Item.kseparation();
        OutItem.kAlignment  = Item.kalignment();
        OutItem.maxAcceleration = Item.maxacceleration();
        OutItem.maxVelocity = Item.maxvelocity();
        OutItem.calculationsPerThread = Item.calculationsperthread();
        OutItem.DeltaTime = Item.deltatime();

        return OutItem;
    }

    template <>
    FORCEINLINE rpc::ActorEnvironmentInfo Proto_Cast(const FActorEnvironmentInfo& Item)
    {
        rpc::ActorEnvironmentInfo OutItem;
        OutItem.set_instancecount(Item.instanceCount);

        OutItem.set_radiuscohesion(Item.radiusCohesion);
        OutItem.set_radiusseparation(Item.radiusSeparation);
        OutItem.set_radiusalignment(Item.radiusAlignment);

        OutItem.set_maprangex(Item.mapRangeX);
        OutItem.set_maprangey(Item.mapRangeY);
        OutItem.set_maprangez(Item.mapRangeZ);

        OutItem.set_kcohesion(Item.kCohesion);
        OutItem.set_kseparation(Item.kSeparation);
        OutItem.set_kalignment(Item.kAlignment);
        OutItem.set_maxacceleration(Item.maxAcceleration);
        OutItem.set_maxvelocity(Item.maxVelocity);
        OutItem.set_calculationsperthread(Item.calculationsPerThread);
        OutItem.set_deltatime(Item.DeltaTime);

        return OutItem;
    }

    template <>
    FORCEINLINE FGRPCEmpty Proto_Cast(const rpc::Empty& Item)
    {
        return FGRPCEmpty();
    }

    template <>
    FORCEINLINE rpc::Empty Proto_Cast(const FGRPCEmpty& Item)
    {
        return rpc::Empty();
    }
}// end namespace 'casts'

class ActorOperationRpcClientWorker : public RpcClientWorker
{

public:
    // Conduits and GRPC stub
    TConduit<TRequestWithContext<FActorInstanceInfo>, TResponseWithStatus<FActorInstanceTransform>>* ConduitGetActorTransform;

    TConduit<TRequestWithContext<FActorEnvironmentInfo>, TResponseWithStatus<FGRPCEmpty>>* ConduitInformActorEnvironmentInfo;

    std::unique_ptr<rpc::ActorOperation::Stub> Stub;



    // Methods
    TResponseWithStatus<FActorInstanceTransform> RequestGetActorTransform(const FActorInstanceInfo& Request, const FGrpcClientContext& Context)
    {
        rpc::ActorInstanceInfo ClientRequest(casts::Proto_Cast<rpc::ActorInstanceInfo>(Request));

        grpc::ClientContext ClientContext;
        casts::CastClientContext(Context, ClientContext);

        grpc::CompletionQueue Queue;
        grpc::Status Status;

        std::unique_ptr<grpc::ClientAsyncResponseReader<rpc::ActorInstanceTransform>> Rpc(Stub->AsyncGetActorTransform(&ClientContext, ClientRequest, &Queue));

        rpc::ActorInstanceTransform Response;
        Rpc->Finish(&Response, &Status, (void*)1);

        void* got_tag;
        bool ok = false;

        GPR_ASSERT(Queue.Next(&got_tag, &ok));
        GPR_ASSERT(got_tag == (void*)1);
        GPR_ASSERT(ok);

        FGrpcStatus GrpcStatus;

        casts::CastStatus(Status, GrpcStatus);
        TResponseWithStatus<FActorInstanceTransform> Result(casts::Proto_Cast<FActorInstanceTransform>(Response), GrpcStatus);

        return Result;
    }

    TResponseWithStatus<FGRPCEmpty> InformActorEnvironmentInfo(const FActorEnvironmentInfo& Request, const FGrpcClientContext& Context)
    {
        rpc::ActorEnvironmentInfo ClientRequest(casts::Proto_Cast<rpc::ActorEnvironmentInfo>(Request));

        grpc::ClientContext ClientContext;
        casts::CastClientContext(Context, ClientContext);

        grpc::CompletionQueue Queue;
        grpc::Status Status;

        std::unique_ptr<grpc::ClientAsyncResponseReader<rpc::Empty>> Rpc(Stub->AsyncInformEnvironmentInfo(&ClientContext, ClientRequest, &Queue));

        rpc::Empty Response;
        Rpc->Finish(&Response, &Status, (void*)1);

        void* got_tag;
        bool ok = false;

        GPR_ASSERT(Queue.Next(&got_tag, &ok));
        GPR_ASSERT(got_tag == (void*)1);
        GPR_ASSERT(ok);

        FGrpcStatus GrpcStatus;

        casts::CastStatus(Status, GrpcStatus);
        TResponseWithStatus<FGRPCEmpty> Result(casts::Proto_Cast<FGRPCEmpty>(Response), GrpcStatus);

        return Result;
    }

    bool HierarchicalInit() override
    {
        // No need to call Super::HierarchicalInit(), it isn't required by design
        std::shared_ptr<grpc::Channel> Channel = channel::CreateChannel(this);
        if (!Channel.get())
            return false;

        Stub = rpc::ActorOperation::NewStub(Channel);

        ConduitGetActorTransform->AcquireResponsesProducer();
        ConduitInformActorEnvironmentInfo->AcquireResponsesProducer();

        return true;
    }

    void HierarchicalUpdate() override
    {
        // No need to call Super::HierarchicalUpdate(), it isn't required by design
        if (!ConduitGetActorTransform->IsEmpty())
        {
            TRequestWithContext<FActorInstanceInfo> WrappedRequest;
            ConduitGetActorTransform->Dequeue(WrappedRequest);

            const TResponseWithStatus<FActorInstanceTransform>& WrappedResponse =
                RequestGetActorTransform(WrappedRequest.Request, WrappedRequest.Context);
            ConduitGetActorTransform->Enqueue(WrappedResponse);
        }

        if (!ConduitInformActorEnvironmentInfo->IsEmpty())
        {
            TRequestWithContext<FActorEnvironmentInfo> WrappedRequest;
            ConduitInformActorEnvironmentInfo->Dequeue(WrappedRequest);

            const TResponseWithStatus<FGRPCEmpty>& WrappedResponse =
                InformActorEnvironmentInfo(WrappedRequest.Request, WrappedRequest.Context);
            ConduitInformActorEnvironmentInfo->Enqueue(WrappedResponse);
        }
    }
};


void UActorOperationRpcClient::HierarchicalInit()
{
    // No need to call Super::HierarchicalInit(), it isn't required by design
    ActorOperationRpcClientWorker* const Worker = new ActorOperationRpcClientWorker();

    Worker->ConduitGetActorTransform = &ConduitGetActorTransform;
    ConduitGetActorTransform.AcquireRequestsProducer();

    Worker->ConduitInformActorEnvironmentInfo = &ConduitInformActorEnvironmentInfo;
    ConduitInformActorEnvironmentInfo.AcquireRequestsProducer();

    InnerWorker = TUniquePtr<RpcClientWorker>(Worker);
}

void UActorOperationRpcClient::HierarchicalUpdate()
{
    // No need to call Super::HierarchicalUpdate(), it isn't required by design
    if (!ConduitGetActorTransform.IsEmpty())
    {
        TResponseWithStatus<FActorInstanceTransform> ResponseWithStatus;
        while (ConduitGetActorTransform.Dequeue(ResponseWithStatus))
            EventGetActorTransform.Broadcast(
                this,
                ResponseWithStatus.Response,
                ResponseWithStatus.Status
            );
    }

    if (!ConduitInformActorEnvironmentInfo.IsEmpty())
    {
        TResponseWithStatus<FGRPCEmpty> ResponseWithStatus;
        while (ConduitInformActorEnvironmentInfo.Dequeue(ResponseWithStatus))
            EventInformActorEnvironmentInfo.Broadcast(
                this,
                ResponseWithStatus.Response,
                ResponseWithStatus.Status
            );
    }
}

bool UActorOperationRpcClient::RequestGetActorTransform(const FActorInstanceInfo& Request, const FGrpcClientContext& Context)
{
    if (!CanSendRequests())
        return false;

    ConduitGetActorTransform.Enqueue(TRequestWithContext$New(Request, Context));
    return true;
}

bool UActorOperationRpcClient::InformActorEnvironmentInfo(const FActorEnvironmentInfo& Request, const FGrpcClientContext& Context)
{
    if (!CanSendRequests())
        return false;

    ConduitInformActorEnvironmentInfo.Enqueue(TRequestWithContext$New(Request, Context));
    return true;
}


